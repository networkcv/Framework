# 一条SQL查询语句是如何执行的？

![image-20200603232224742](img/一条语句的执行过程/image-20200603232224742.png)

大的来说，MySQL可以分为 Server层和 存储引擎层。

## Server 层

### 连接器

负责与客户端建立连接、获取权限、维持和管理连接。

使用下面命令，就可以与指定ip：prot 进行数据库连接了，在进行TCP握手之后，连接器就要认证你的身份，也就是你的用户名和密码是否正确，然后才会去权限表里验证你拥有的权限，之后这个连接里的全县判断逻辑，都依赖于此时读到的权限，因此当一个用户的权限被修改后，重新连接才能生效。

```sql
mysql -h$ip -P$port -u$user -p
```

连接有长连接和短连接之分，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接，如果连接后长时间没有操作，连接器也会将它断开，这个时间是由参数 wait_timeout 控制的，默认为 8 小时；短连接则是每次执行完很少的几次查询就断开连接，下次查询再重新建一个。

建立连接的过程比较复杂，因此在使用中尽量减少建立连接的动作，也就是尽量使用长连接。

全部使用长连接后，MySQL使用时内存涨的特别快，原因在于sql在执行时临时使用的内存（比如查出的数据）是管理在 **连接对象** 里面的，这些资源会在连接断开的时候释放，所以长时间累计下来，可能会导致内存占用过大，被系统强行杀掉（OOM），从现象上看就是MySQL异常重启了。

怎么解决这个问题呢？你可以考虑以下两种方案。

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开
   连接，之后要查询再重连。
2. 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行
   mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，
   但是会将连接恢复到刚刚创建完时的状态。

### 查询缓存

连接建立后，就可以执行sql了，执行逻辑就会来到第二步：查询缓存。

MySQL 拿到一个查询请求后，会首先到查询缓存中去看看，之前是否执行过这条sql，执行过的话，会在查询缓存中保留，这样就可以直接通过 key（ 查询语句），获取到 value （查询结果）。

如果语句没有在缓存中，才会去执行后面的步骤，执行后再将结果进行缓存。如果查询命中的话，这个效率会非常高，如果查询缓存失效的非常频繁，只要有对一个表的更新，这个表上的所有查询缓存都会被清空，因此查询缓存是一个双刃剑，对与更新频繁的数据表，不建议使用，对于一些静态表、配置表，这些表的查询才适合使用查询缓存。

 MySQL 也提供了这种 “ 按需使用 ” 的方式。你可以将参数 query_cache_type 设置成DEMAND ，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：

```sql
mysql> select SQL_CACHE * from T where ID=10 
```

需要注意的是， MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。

### 分析器

如果没有命中查询缓存，就要开始真正执行语句了。首先， MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。

分析器先会做 “ 词法分析 ” 。你输入的是由多个字符串和空格组成的一条 SQL 语句， MySQL 需要识别出里面的字符串分别是什么，代表什么。

MySQL 从你输入的 "select" 这个关键字识别出来，这是一个查询语句。它也要把字符串 “T” 识别成 “ 表名 T” ，把字符串 “ID” 识别成 “ 列 ID” 。

做完了这些识别以后，就要做 “ 语法分析 ” 。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

如果你的语句不对，就会收到 “You have an error in your SQL syntax” 的错误提醒，比如下面这个语句 select 少打了开头的字母 “s” 。

一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接 “use near” 的内容。

### 优化器

经过了分析器， MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（ join ）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join ：

```sql
mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
```

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2 ，再判断 t2 里面 d 的值是否等于 20 。
- 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1 ，再判断 t1 里面 c 的值是否等于 10。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

### 执行器

MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。
开始执行的时候，**要先判断一下你对这个表 T 有没有执行查询的权限**，如果没有，就会返回没有权限的错误，如下所示。

```sql
mysql> select * from T where ID=10;
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
比如我们这个例子中的表 T 中， ID 字段没有索引，那么执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10 ，如果不是则跳过，如果是则
   将这行存在结果集中；
2. 调用引擎接口取 “ 下一行 ” ，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了。

对于有索引的表，执行的逻辑也差不多。第一次调用的是 “ 取满足条件的第一行 ” 这个接口，之后循环取 “ 满足条件的下一行 ” 这个接口，这些接口都是引擎中已经定义好的。

你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此 引擎扫描行数跟rows_examined 并不是完全相同的。



## Question

如果表 T 中没有字段 k ，而你执行了这个语句 select * from T where k=1, 那肯定是会报 “ 不存在这个列 ” 的错误： “Unknown column ‘k’ in ‘where clause’” 。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？

应该是在执行器阶段报出来的，执行器阶段首先判断执行SQL语句的用户，有没有对目标表执行那些SQL语句的权限。如果没有，就报权限错误。如果有，再打开表，通过存储引擎提供的接口，对表进行操作。而获知一个表是否存在某个列，是需要在打开一个表之后才能知道这个列到底是有没有。

个人理解：

数据表的字段是否存在，对这个表而言也算是它的 “隐私”，如果你没有权限访问该表的话，你自然也不应该知道它有哪些字段，因此出于对表内部结构的保密，会在验证权限后决定是否告知连接对象。

猜测也许还有一种可能就是，在分析器阶段抛出了这个错误，然后在执行器阶段验证身份时，发现了一个更大错误，也就是没有访问权限，最后将大错误（没有访问权限）抛出而忽略掉小错误（字段不存在），不过这种可能性比较小，因为分析器就是做的功能很简单，只是进行词法和语法分析，而且如果前边发生了错误，程序肯定不会往下执行了。

参考：[极客时间——MySQL 实战45讲 第一课留下问题的分析](http://ylinknest.top/index.php/2019/04/15/极客时间-mysql-实战45讲-第一课留下问题的分析/)





# 一条 SQL 更新语句是如何执行的

我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个
整型字段 c ：

```sql
mysql> create table T(ID int primary key, c int);
```

如果要将 ID=2 这一行的值加 1 ， SQL 语句就会这么写：

```sql
mysql> update T set c=c+1 where ID=2;
```

SQL 的更新操作也可以使用这种图的流程。

![](img/一条语句的执行过程/image-20200603232224742-8550035.png)

一样的流程就不多做赘述了。

1. **连接器：**建立连接。
2. **查询缓存：**如果一个表上有更新的时候，和这个表有关的查询缓存都会失效。
3. **分析器：** 分析器会通过词法分析和语法分析得知这是一条更新语句。
4. **优化器：** 决定使用 ID 这个主键索引。
5. **执行器：** 执行器负责具体执行，找到这一行，然后更新。

与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主
角： redo log （重做日志）和 binlog （归档日志）。如果接触 MySQL ，那这两个词肯定是绕不过
的，， redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。

## redo log 日志模块 

由于每次更新操作都写进磁盘，然后磁盘要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高，因此不如先把这些更新操作先记录下来，等到空闲的时候再集中去更新磁盘上的记录，这样的做法更高效。

就是 MySQL 里经常说到的 WAL 技术， WAL 的全称是 Write-Ahead Logging ，它的关键点就是先写日志，再写磁盘。

具体来说，当有一条记录需要更新的时候， InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时， InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

redo log 有固定的大小，当更新频繁的时候，redo log很容易被写满，这时候就需要将redo log 中的一部分记录更新到磁盘上，以留出足够的空间来记录新的更新操作。

redo log 就像一个循环链表。

write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。

checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。

如果 write pos追上 checkpoint ，表示 redo log 满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint 推进一下。

![image-20200604225104117](img/一条语句的执行过程/image-20200604225104117.png)

有了 redo log ， InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe 。

## binlog 日志模块

前面我们讲过， MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能
层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是
InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog （归档日志）。

为什么会有两份日志呢？

因为最开始 MySQL 里并没有 InnoDB 引擎。 MySQL 自带的引擎是 MyISAM ，但是 MyISAM 没有
crash-safe 的能力， binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL
的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统 —— 也就是
redo log 来实现 crash-safe 能力。

## 这两种日志有以下三点不同

1. redo log 是 InnoDB 引擎特有的； binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是 “ 在某个数据页上做了什么修改 ” ，就像是抄作业只抄了答案，至于是怎么做到的就不知道了；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “ 给 ID=2 这一行的 c 字段加 1 ” ，这个就好像是抄作业连解题过程一起抄了，可以直接计算过程来得到正确的答案。
3. redo log 是循环写的，空间固定会用完； binlog 是可以追加写入的。 “ 追加写 ” 是指 binlog 文件
   写到一定大小后会切换到下一个，并不会覆盖以前的日志。

## 执行 Update 语句时的内部流程

有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语
句时的内部流程。

1. 执行器先找引擎取 ID=2 这一行。 ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一
   行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然
   后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1 ，比如原来是 N ，现在就是 N+1 ，得到新的一行
   数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处
   于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog ，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（ commit ）状态，更
   新完成。

这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

![image-20200604230405988](img/image-20200604230405988.png)

注意最后的三步，将 redo log 的写入拆成了两个步骤： prepare 和 commit ，这就是 " 两阶段提交 " 。