# 常见缓存淘汰策略:
先进先出策略FIFO（First In，First Out）：先进入缓存的最先被淘汰。
最少使用策略LFU（Least Frenquently Used）：最近没有被访问的先被淘汰。
最近最少使用策略LRU（Least Recently Used）：最近访问最少的先被淘汰。

LRU:
_146_LRU 缓存.java
链表实现：该数据结构主要包含四种操作，put get remove 以及私有的 insertHead方法，通过定义头尾两个双向双向链表，再结合map存放key对应的节点

LFU:
460. LFU 缓存


# 堆
大顶堆和小顶堆
大顶堆：用树来表示的话，当前节点大于左右节点，整个堆最大的节点是根节点。
小顶堆：当前节点小于左右节点，整个堆最小的节点是根节点。
使用优先级队列自定义堆的比较逻辑，(a,b)->a-b 是升序，(a,b)->b-a 是倒序
PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> {return map.get(a) - map.get(b);});


# 跳表
跳表是链表的另一种变形,可以加速链表的遍历过程。普通的链表需要一个接着一个的遍历，如果链表有序的话，这种挨个遍历的方式不够高效，像数组因为可以随机访问，
所以可以通过二分查找来优化查找性能，那么链表节点能不能也通过类似二分的方式加速呢，答案是可以的，跳表就是使用了这种思想，普通链表节点会通过next记录下一个节点元素，
如果想访问下下一个节点，那一定要先访问下一个节点，这个就像地铁一站接着一站的前进，如A->B->C->D->E，但如果再建立一条快速线路从A直接到C，这样A站既能到B站，也能直接到C站
那么从A到D，最快的方式就是A->C，再从C->D。那么A站要同时记录两个后续节点的信息，我们可以通过一个二维数组来记录forward[]。forward[0]表示第普通站的下一站指向，
forward[1]表示快速线的下一站指向，注意，不是每个节点都需要在快速线路上，例如上边的B站，
我们可以简单的每隔一个站建立快速线路，快速线就是：A->C->E，普通路线是A->B->C->D->E。
插入：
跳表需要定义一个头节点，在插入前根据节点数量判断是否需要在快速线上建站，奇数的话建站，偶数的话不建。update[i]表示建站的层数的头节点，奇数的话i的取值范围是[0，1],
偶数的话i的取值范围是只能是0，其中update[0]表示只建基础站的头节点，和链表的插入类似，向后遍历当前节点，判断下一个节点大于插入元素的值停止，
先用新节点的forward[i]指向下一个节点，再将当前节点的下一个节点forward[i]指向新节点。
 for (int i = 0; i < update.length; i++) {
    //遍历找到插入位置 update[i]可以看作当前层的cur,update[i].forwards[i]可以看作cur.next
    while (update[i].forwards[i] != null && update[i].forwards[i].data < value) {
        update[i] = update[i].forwards[i];
    }
}
查找：
优先从快速站查找到小于target值的前一个节点，然后向下走下一层普通线，同样也走到小于target值的前一个节点，接下来判断前一个节点存放的forwar[0].data是否等于target
不等于则说明target不存在,主要这里的forwar[0]还需要判空。
删除：
删除同理，遍历每层找到删除位置，将cur.next=cur.next.next，如果cur.next为null则表示没找到删除节点