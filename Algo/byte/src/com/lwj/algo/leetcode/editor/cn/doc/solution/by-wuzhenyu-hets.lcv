### 解题思路

由于二叉搜索树的特性,我们在dfs时便可以顺序输出
所以我们可以在dfs时便修改节点的左右指针, 使其符合题目要求
但是从小到大进行修改时头结点的值需要额外开辟空间保存

但如果是从大到小dfs, 便不需要了, 遍历到最后自然是头结点.

### dfs优化前

* java

```java
class Solution {
    TreeNode head = null, pre = null;
    public void dfs(TreeNode node) {
        if (node == null) return;
        dfs(node.left);
        if (pre != null) pre.right = node;
        else head = node;
        pre = node;
        dfs(node.right);
        node.left = null;
    }
    public TreeNode increasingBST(TreeNode root) {
        dfs(root);
        return head;
    }
}
```

### dfs优化后

* java

```java
class Solution {
    TreeNode head = null;
    public void dfs(TreeNode node) {
        if (node == null) return;
        dfs(node.right);
        node.right = head;
        head = node;
        dfs(node.left);
        node.left = null;
    }
    public TreeNode increasingBST(TreeNode root) {
        dfs(root);
        return head;
    }
}
```

### 栈-优化前

* java

```java
class Solution {
    public TreeNode increasingBST(TreeNode root) {
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        TreeNode node = root, head = null, pre = null;
        while (node != null || !stack.isEmpty()) {
            while (node != null) {stack.addLast(node); node = node.left;}
            node = stack.removeLast();
            if (pre != null) pre.right = node;
            else head = node;
            pre = node;
            node.left = null;
            node = node.right;
        }
        return head;
    }
}
```

### 栈-优化后

* java

```java
class Solution {
    public TreeNode increasingBST(TreeNode root) {
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        TreeNode node = root, head = null;
        while (node != null || !stack.isEmpty()) {
            while (node != null) {stack.addLast(node); node = node.right;}
            node = stack.removeLast();
            node.right = head;
            head = node;
            node = node.left;
            head.left = null;
        }
        return head;
    }
}
```

