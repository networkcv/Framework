### 解题思路

要求非负整数 x 的平方根，相当于 y = √x，由于这个函数是**单调递增（有序）**的，所以可以用**二分查找**求解。

### 二分查找

本题采用二分查找求解的解题步骤如下：
1. 确定**左右边界**；

2. 根据**中间值 mid 的平方与 x 的大小**关系，确定**待查找的区间**；

3. 确定最后返回的是**左边界还是右边界（跳出循环后）**。

### 说明

1、左右边界分别取 **left = 1** 和 **right = x / 2 + 1**。

原因：由于提到 x 是**非负整数 x ≥ 0**，**当非负整数 x ≠ 0 时，其平方根一定落在区间 [1, x / 2 + 1]**。

右边界 right 取 x / 2 + 1，主要是考虑到当非负整数 **x = 1** 的特殊情况，如果右边界 right 取 x / 2，则会使得右边界小于左边界，**查找区间为空**，直接跳出查找区间，导致结果错误。

2、为了防止**整型溢出**的风险，直接用 **mid 和 x / mid 取代 mid * mid 和 x** 进行比较。

3、最后返回**右边界 right**，这是因为当查找区间**左闭右闭**时，循环退出的条件是 **left = right + 1**，而本题有**向下取整**的意味（8 的平方根是 2）。

### Show me the Code

* c

```c
int mySqrt(int x) {
    /* 查找区间为 [1, x / 2 + 1] */
    int left = 1, right = x / 2 + 1;
    /* 循环不变量，查找区间始终保持左闭右闭 */
    while (left <= right) {
        /* 防止出现整型溢出的风险 */
        int mid = left + ((right - left) >> 1);
        if (mid > x / mid) {
            right = mid - 1;
        } else if (mid < x / mid) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return right;
}
```

### 补充说明

上面的代码，**对 x = 0 也适用**。

### 题解二

对于了解**二分查找**的小伙伴，一定会想作者上面的题解的查找区间是**左闭右闭**的，查找区间能否是**左闭右开**呢？

先说答案，答案是**能**。

其实这两种写法都可以，具体采用哪种可以根据题目而定，**哪种方便选哪种**。

查找区间要想写成**左闭右开**，可能需要对上面的代码做一些修改。

这是因为如果查找区间是**左闭右开**的话，则循环退出的条件是 **left = right** 而不是上面的 **left = right + 1**。

### 说明

1、左右边界分别取 **left = 1** 和 **right = x / 2 + 2**。

根据上面解法说明中第 1 点的分析，可以将查找区间设置为 [1, x / 2 + 2)。

2、为了防止**整型溢出**的风险，还是取 mid 和 x / mid 进行比较。

3、最后返回**right - 1**，这是因为当查找区间**左闭右开**时，循环退出的条件是 **left = right**，本题有**向下取整**的意味（8 的平方根是 2），并且取不到右边界（左闭右开），再加上取值是整数，所以取 **right - 1**，当然也可以是 **left - 1**。

### Show me the Code

* c

```c
int mySqrt(int x) {
    /* 查找区间为 [1, x / 2 + 2) */
    int left = 1, right = x / 2 + 2;
    /* 循环不变量，查找区间始终是左闭右开 */
    while (left < right) {
        /* 防止出现整型溢出的风险 */
        int mid = left + ((right - left) >> 1);
        if (mid > x / mid) {
            right = mid;
        } else if (mid < x / mid) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return right - 1;
}
```

