堆：
    堆是一个完全二叉树(叶子节点在最底下两层，最后一层叶子节点都靠左排列，除最后一层外，其他层节点数要最大)
    堆中每一个节点的值都大于等于(小于等于)其左右节点的值，根元素最大则是最大堆，最小则为最小堆。
    堆的基础操作主要依赖堆化，堆化的时间复杂度与树的高度成正比，堆本身就是一个完全二叉树，其高度不会超过log2N，
    所以往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logN)

堆的实现：
    insert
        借助完全二叉树用数组存放支持随机访问的特性，假设索引从1开始存放数据的数组中，i的左子节点为2i，右子节点为2i+1，父节点为i/2
        a[i]=data
        while(i/2>0&&a[i]>a[i/2]){
            swap(a[i],a[i/2])
            i=i/2
        }
        整个插入的过程，是将插入元素进行位置交换调整，达到满足堆的特性的过程，称之为 堆化(heapify)
        因为元素是从最下面不停向上调整的，所以这是一个自下而上的堆化，
    removeMax
        删除堆顶元素
        将堆中末尾元素覆盖堆顶，堆中计数器减一，进行逻辑删除，然后进行自上而下的堆化
        while(true){
            int maxPos=i;
            if(i*2<=n&&a[i]<a[i*2]) maxPos=i*2;
            if(i*2+1<=2&&a[maxPos]<a[i*2+1]) maxPos=i*2+1;
            if(maxPos==i) break;
            swap(a[i],a[maxPos]);
            i=maxPos;
        }

堆排序：
    建堆的时间复杂度O(logN)，排序对n个元素进行自上而下的堆化O(logN),排序过程时间负责度为O(NlogN),所以整个堆排序的时间复杂度为O(NlogN)
    1.原地建堆:
        对数组元素进行堆化
        自下而上

        自上而下

    2.排序:
        类似于删除堆顶元素操作，将数组最后一位与栈顶元素(也就是最大值)交换位置，然后对交换后的栈顶元素（数组最后一位）进行堆化，
        这个时候要堆化的数组长度需要减少一位，因为当前数组的最后一位元素是之前的栈顶元素，重复这个过程直至最后一个元素


实际开发中快排效果比堆排效果好原因：

    第一点,堆排序数据访问的方式没有快速排序友好。对于快速排序来说,数据是顺序访问的。而对于堆排序来说,数据是跳着访问的。
    比如,堆排序中,最重要的一个操作就是数据的堆化。比如下面这个例子,对堆顶节点进行堆化,会依次访问数组下标是1, 2, 4, 8的
    元素,而不是像快速排序那样,局部顺序访问,所以,这样对CPU缓存是不友好的。

    第二点,对于同样的数据,在排序过程中,堆排序算法的数据交换次数要多于快速排序。我们在讲排序的时候,提过两个概念,有序度
    和逆序度。对于基于比较的排序算法来说,整个排序过程就是由两个基本的操作组成的,比较和交换(或移动) 。快速排序数据交换
    的次数不会比,逆序度多。但是堆排序的第一步是建堆,建堆的过程会打乱数据原有的相对先后顺序,导致原数据的有序度降低。
    比如,对于一组已经有序的数据来说,经过建堆之后,数据反而变得更无序了.