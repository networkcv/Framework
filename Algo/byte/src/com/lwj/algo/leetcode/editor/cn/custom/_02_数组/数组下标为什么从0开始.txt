什么是数组
    数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

1.线性表
    线性表就是数据排成像一条线一样的结构。
    常见的线性表结构：数组，链表、队列、栈等。

2. 连续的内存空间和相同类型的数据
    优点：两限制使得具有随机访问的特性
    缺点：删除，插入数据效率低

数组怎么根据下标随机访问的？
    通过寻址公式，计算出该元素存储的内存地址：
    a[i]_address = base_address + i * data_type_size

为何数组插入和删除低效？
    插入：
        若有一元素想往int[n]的第k个位置插入数据，需要在k-n的位置往后移。
        最好情况时间复杂度 O(1)
        最坏情况复杂度为O(n)
        平均负责度为O(n)
        如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。这样时间复杂度就将为 O（1）了。

    删除：
        与插入类似，为了保持内存的连续性。
        最好情况时间复杂度 O(1)
        最坏情况复杂度为O(n)
        平均负责度为O(n)

提高效率：将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作。这也是 JVM 标记清除垃圾回收算法的核心思想。

数组访问越界问题
    C语言中的数据越界是一种未决行为，一般比较难发现的逻辑错误。相比之下，Java会有越界检查。

用数组还是容器？
    数组先指定了空间大小，容器如ArrayList可以动态扩容。
    1.希望存储基本类型数据，可以用数组
    2.事先知道数据大小，并且操作简单，可以用数组
    3.直观表示多维，可以用数组
    4.业务开发，使用容器足够，开发框架或追求性能，优先考虑数组。

为什么数组要从 0 开始编号？
    由于数组是通过寻址公式，计算出该元素存储的内存地址：
    a[i]_address = base_address + i * data_type_size
    如果数组是从 1 开始计数，那么就会变成：
    a[i]_address = base_address + （i-1）* data_type_size

    对于CPU来说，多了一次减法的指令。
    当然，还有一定的历史原因。

————课后思考————

    1.我理解的JVM标记清除垃圾回收算法：在标记阶段会标记所有的可访问的对象，在清除阶段会遍历堆，回收那些没有被标记的对象。现在想想，和「如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。」思想类似。

    2. 对于一维数组：a[i]_address = base_address + （i）* data_type_size
    二维数组如果是m*n，那么a[i][j]== base_address + （i*n+j）* data_type_size。