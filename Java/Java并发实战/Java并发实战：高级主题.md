# 13 显式锁
# 14 构建自定义的同步工具
# 15 原子变量与非阻塞同步机制
# 16 Java内存模型
之前所讲的设计问题，如安全发布，同步策略和规范以及一致性等，它们的安全性都来自于JMM，理解JMM你可以更容易的使用它们。

## 16.1 什么是内存模型，为什么需要它
在编译器中生成的指令顺序，可以与源代码中的顺序不同；此外编译器还会把变量保存在寄存器而不是内存中；处理器何以采用乱序或并行等方式来执行指令；缓存可能会改变写入变量提交到主内存的次序；而且保存在处理器本地缓存的值，对其他处理器是不可见的。这些因素都会使一个线程无法看到变量的最新值，如果没有正确使用同步，会导致其他线程中的内存执行操作似乎存在乱序执行。
近些年计算机性能的提升原因除了时钟频率的提高，其他很大程度上归功于指令重排序措施，此外还用不断提升的并行性——动态指令调度，猜测执行以及完备的多级缓存。随着处理变得越来越强大，编译器也不断改进，通过对指令重新排序来实现优化执行，以及使用成熟的全局寄存器分配算法，由于时钟频率越来越难以提高，因此多处理器制造厂商转而生成多核处理器，因为能够提高的只有硬件的并行性。
在多线程环境中，维护程序的串行性将导致很大的性能开销，在并发应用程序中的线程，大部分时间都在执行各自的人刷，多线程之间的协调操作只会降低应用程序的运行速度，只有多个线程要共享数据时，才必须协调它们之间的操作，并且JVM依赖程序通过同步操作来找出这些协调操作将在何时发生。

现代处理器和编译器中使用的程序性能提升措施：

### 16.1.1操作系统平台的内存模型
在共享内存的多处理器体系架构中，每个处理器都拥有自己的缓存，并且定期与主内存进行协调。在不同的处理器架构中提供了不同级别的缓存一致性，其中一部分只提供最小的保证，即允许不同处理器在任意时刻从同一个存储位置上看到不同的值，大多数情况下每个处理器不需要知道其他处理器正在执行的工作，因此处理器会适当放宽存储一致性的保证，以换取性能的提升，此外还定义了一些特殊的指令（称为内存栅栏或栅栏），当需要共享数据时，这些指令就能实现额外的存储协调保证，Java提供了自己的内存模型(JMM)，并且JVM通过在适当的位置插入内存栅栏来屏蔽在JMM与底层平台模型之间的差异。
在程序运行过程中，所有的变更会先在寄存器或本地cache中完成，然后才会被拷贝到主存以跨越内存栅栏，此种跨越序列或顺序称为happens-before。happens-before本质是顺序，重点是跨越内存栅栏。
通常情况下，写操作必须要happens-before读操作，即写线程需要在所有读线程跨越内存栅栏之前完成自己的跨越动作，其所做的变更才能对其他线程可见。

### 16.1.2重排序
在没有充分同步的程序中，如果调度器采用不恰当的方式来交替执行不同线程的操作，那么将导致不正确的结果。
更糟的是，JMM还使得不同的线程看到的执行操作是不同的，从而导致在缺少同步的情况下，要推断执行顺序将变得更加复杂，各种使操作延迟或者看似乱序执行的不同原因，都可以归为重排序。
```java
    public class possibleReordering{
        static int x=0,y=0;
        static int a=0,b=0;
        public static void main(String[]args){
            Thread a=new Thread(()->{
                a=1;
                x=b;
            });
            Thread b=new Thread(()->{
                b=1;
                y=a;
            })
            a.start();b.start();
            a.join();b.join();
            System.out.println("("+x+" , "+y+")");
        }
    }
```
由于缺少同步机制，输出的结果可能是(0,0)、(1,0)、(0,1)，甚至可能是(0,0)，由于每个线程中的各个操作之间不存在数据流的依赖性，因此这些操作可以是乱序执行的。（即使这些操作按照顺序执行，在将缓存刷新到主内存的不同时序也可能出现这种情况）

下图为由于执行重排序导致输出(0,0)的情况：
![指令重排序.jpg](./指令重排序.jpg)

仅仅是一个简单的程序因为重排序列举结果都比较困难，内存级别的重排序会使程序行为变得不可预测。如果没有同步，那么推断执行顺序将是非常困难，相比而言在程序中正确使用同步是多么简单。同步将限制编译器、运行时和硬件对内存重排序的方式，从而在实施重排序的时不会破坏JMM提供的可见性保证。当前主流处理器架构中，内存模型都非常强大，使得读取volatile变量的性能与读取非volatile变量的性能大致相当。

### 16.1.3Java内存模型简介
Java内存模型是通过各种操作来定义的，包括对变量的读/写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。JMM为程序中所有的操作定义了一个偏序关系，称为Happens-Before。要想保证执行操作B的线程看到操作A的结果，无论A和B是否在同一个线程中执行，那么A和B之间必须满足Happens-Before关系。如果两个操作之间缺乏Happens-Before关系，那么JVM可以对它们任意的排序。
当一个变量被多个线程读取并且至少被一个线程写入是，如果在读操作和写操作之间没有依照Happens-Before来排序，那么就会产生数据竞争问题。在正确同步的程序中不存在数据竞争，并会变形出串行一致性，这意味着程序中所有的操作都会按照一种固定的和全局的顺序执行。

>数据竞争(Data Race)：所谓的数据竞争，很容易理解，多个线程同时访问同一数据导致冲突（数据不正确）就产生了数据竞争。其中，“访问”包括读和写操作，所以自然，数据竞争就包括了读写竞争、写写竞争。


Happens-Before的规则包括：
程序顺序规则：如果程序中操作A在操作B之前，那么在线程中A操作将在B操作之前执行。
监视器锁规则：在监视器上解锁操作必须在同一个监视器锁上的加锁操作之前执行。
volatile变量规则：对volatile变量的写入操作必须在对该变量的读操作之前执行。
线程启动规则：在线程上对Thread.start()的调用必须在该线程中执行任何操作之前执行。
线程结束规则：线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从Thread.join中成功返回，或者调用Thread.isAlive时返回false。
中断规则：当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行(通过抛出InterruptedException，或者调用isInterrupted和interrupted)。
终结器规则：对象的构造函数必须在启动该对象的终结器之前执行完成。
传递性：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。

### 16.1.4 借助同步
由于Happens-Before的排序功能很强大，因此有时候可以“借助”现有同步机制的可见性属性。这需要将Happens-Before的程序顺序规则与其他某个顺序规则（通常是监视器锁规则或者volatile变量规则）结合起来，从而对某个未被锁保护的变量的访问操作进行排序。这项技术由于对语句的顺序非常敏感，因此很容易出错。它是一项高级技术，而且只有当需要最大限度地提升某些类（例如ReentrantLock）的性能时，才应该使用这项技术。
在FutureTask的AbstractQueuedSynchronizer中就使用了这种技术，AQS维护了一个表示同步器状态的整数，FutureTask用这个整数来保存任务的状态：正在运行，已完成和已取消。但FutureTask还维护了其他一些变量，例如计算的结果。当一个线程调用set来保存结果并且另一个线程调用get来获取该结果时，这两个线程最好按照Happens-Before进行排序。这可以通知将执行结果的引用声明为volatile类型来实现，但利用现有的同步机制可以更容易地实现相同的功能。


## 16.2 发布
第3章介绍了如何安全或者不安全的发布一个对象，对于其中介绍的各种安全技术，它们的安全性都来自于JMM提供的保证，而造成不安全发布的真正原因，就是在“发布一个共享对象”与“另一个线程访问该对象”之间缺少一种Happens-Before排序。

### 16.2.1 不安全的发布
当缺少Happens-Before关系时，就可能出现重排序问题，这就解释了为什么在没有充分同步的情况下发布一个对象会导致另一个线程看到一个只被部分构造的对象。在初始化一个新的对象时需要写入多个变量，即新对象的各个域。同样，在发布一个引用时也需要写入一个变量，即新对象的引用。如果无法确保发布共享引用的操作在另一个线程加载该共享引用之前执行，那么对新对象引用的写入操作将在对象中各个域的写入操作重排序，在这种情况下，另一个线程可能看到对象引用的最新值，但同时也可能看到对象某些状态包含的无用值，即一个被部分构造对象。
```java
    public class UnSafeLazyInitialization{
        private static Resource resource;
        public static Resource getInstance(){
            if(resource == null)
                resource =new Resource();
            return resource;
        }
    }
```
线程A先调用getInstance(),resource为空，初始化一个新的Resource，（此处不必考虑多次创建实例的问题）然会将这个实例地址写入resource(将resource指向实例对象)，当线程B随后调用getInstance()，resource不为空，因此使用这个已经构造好的Resource，看起来似乎没什么问题，但线程A写入resource的操作和线程B读取resource的操作之间不存在Happens-Before关系，
当新分配一个Resource时，Resource的构造函数把新实例中的各个域由默认值(由Object构造函数写入的)修改为它们的初始值。再将resource指向Resource实例，如果由于重排序，导致对resource的写入操作先于对Resource各个域的写入操作执行，那么线程B就可能看到一个被部分构造的Resource实例，通俗来说就是new完的对象还没初始化，就有引用指到这个对象了，而且还被其他线程读到了。
> 除了不可变对象以外，使用被另一个线程初始化的对象通常都是不安全的，除非对象的发布操作是在使用该对象的线程开始使用之前执行的。

### 16.2.2 安全的发布
Happens-Before排序是在内存访问级别上操作的，它是一种“并发级别汇编语言”，而安全发布的运行级别更接近程序设计。

### 16.2.3 安全初始化模式
```java
    public class ResourceFactory{
        private static class ResourceHolder{
            public static Resource resource = new Ressource();
        }
        public static Resource getResource(){
            return ResourceHolder.resource;
        }
    }
```

### 16.2.4 单例模式-双重检查锁
```java
    public class SingleClass{
        private static Resource resource;
        public static Resource getInstance(){
            if(resource == null){
                synchronized(this){
                    if(resource == null){
                        resource = new Resource();
                    }
                }
            }
            return resource;
        }
    }
```
这个例子可以看出人们能很好地理解“独占性”，但却没有很好的理解“可见性”的含义。上面例子问题在于，获取一个已构建好的Resource引用没有使用同步，虽然在创建Resource实例时使用了同步，假设线程A创建了对象还没初始化，就将引用执行这个对象，线程B调用getInstance(),resoucre不为空，但却指向一个部分构造的实例。
在JDK5之后，将resource声明为volatile类型，就可以使用双重检查锁了，因为volatile禁止了指令重排序，volatile变量的读取操作性能通常只是略高于非volatile变量读取性能操作。

## 小结
Java内存模型说明了某个线程的内存操作在哪些情况下对于其他线程是可见的，其中包括确保这些操作是按照一种Happens-Before的偏序关系进行排序，而这种关系是基于内存操作和同步操作等级别来定义的。然而如果使用第二章和第三章结束的更高级规则，例如@GuardedBy和安全发布，那么即使不考虑Happens-Before的底层细节，也能确保线程安全性。