单例模式
    windows的任务管理器、回收站
    读取配置文件的类、网站计数器、应用程序的日志应用
    数据库连接池的设计、每个servlet也是单例
    Spring中的application对象单例、每个Bean也是单例(action是多例)、控制器对象也是单例

    饿汉式：
        static实例随类加载而加载，类加载器加载时线程安全，不需要在获取实例的方法上再加同步
        优缺点：线程安全，不加锁并发效率高，没有延迟加载，可能会造成资源浪费
    懒汉式：
        优缺点：延时加载，提高资源利用率，但因为加锁，并发效率较低
    双重检测锁：
        不在方法体上加synchronized，在第一次创建时在内部if判判断里加锁，即提高了并发效率又延时加载
        由于编译器优化和JVM底层内部模型原因，偶尔会出问题，不建议使用
    静态内部类式：
        外部类没有static属性，则不会像饿汉式那样立即加载对象
        只有真正调用getInstance()，才会加载静态内部类，加载类时是线程安全的
        兼备了并发高效调用和延迟加载的优势
    枚举式：
        可以防止反射和反序列化的漏洞
        调用效率高，唯一不足是没有懒加载

总结
    饿汉式(线程安全，调用效率高，不能延时加载)
    懒汉式(线程安全，调用效率不高，可以延时加载)
    双重检测锁式(由于JVM底层内部模型原因，偶尔会出问题，不建议使用)
    静态内部类式(线程安全，调用效率不高，可以延时加载)
    枚举式(线程安全，调用效率高，不能延时加载，天然防止反射和序列化漏洞)

如何选用？
    单例对象 占用 资源少，不需要 延时加载：
        枚举式 好于 饿汉式
    单例对象 占用 资源大， 需要 延时加载：
        静态内部类式 好于 懒汉式