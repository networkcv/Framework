原型模式
    业务场景：
         FPS游戏中玩家射击出的子弹，在短时间内可能出产生大量的子弹对象。
         方式一：通过不停的执行new bullet()，这样虽然可以实现，但是new产生一个对象需要非常繁琐的数据准备或访问权限，十分
         消耗cpu和内存。
         方式二：通过原型模式来克隆子弹对象，通过new的方式来产生第一个子弹对象，第二个子弹对象不再通过java代码一行一行执
         行来创建对象，而是直接在内存中根据该对象的原型直接复制出一个新的对象来，复制出的新对象并不是简单的引用指向原型对
         象，而是在内存中复制出来的一个和原型对象一模一样的对象。

    总结：
        通过new 产生对象的成员变量都是默认值，而克隆模式产生对象的成员变量值是和原型对象一模一样的。如果是引用类型，那么
        该引用和原型对象指向同一个引用对象，这种情况称为浅克隆，如果其中一个对引用对象进行操作，那么另外一个也会受到影响
        而深克隆就能避免这种问题

    应用场景：
        通过new产生一个对象非常繁琐的数据准备和访问权限
        原型模式很少单独出现，一般是结合工厂模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。
        Spring中bean的创建实际就是：单例模式和原型模式搭配工厂模式

    模式实现：
        Cloneable接口和clone方法
        Cloneable接口和Serialize接口一样，都是空接口 起标志作用 必须实现，具体的克隆方法是在Object类中定义的
        prototype模式中核心是跳过代码执行，直接在内存中进行对象的复制，而java不擅长对内存进行操作。但JDK的开发人员已经为
        我们提供了该功能的底层实现，我们只需要调用clone方法就可以实现。
        通过这个克隆方法，jvm会直接去内存中拷贝原始数据流然后，而省去了很多复杂操作（类加载，实例化，初始化）
        所以克隆的速度远远快于实例化操作