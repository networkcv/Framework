# 计算机系统基础知识

## 计算机硬件组成

五大基本硬件，运算器、控制器、存储器、输入设备和输出设备。

运算器+控制器 组成CPU，CPU完成算术和逻辑运算及控制功能。

存储器是计算机系统中的记忆设备，分为内存和外存。

## 中央处理单元

**CPU功能：**

- 程序控制（控制器），通过执行指令来控制程序的执行顺序。
- 操作控制（控制器），一条指令功能的实现需要若干操作信号配合来完成，CPU 产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。
- 时间控制（控制器），CPU 对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。
- 数据处理（运算器），算术运算和逻辑运算。

CPU还需要响应内部或外部的系统中断或者异常，进行处理。

**CPU组成**： 

运算器、控制器、寄存器 和 内部总线 等部件组成。CPU根据指令周期的不同阶段来区分二进制的指令和数据。

**运算器：**

- 算术逻辑单元ALU：实现数据的算术和逻辑运算
- 累加寄存器AC：运算结果或者原操作数的存放区
- 数据缓存寄存器DR：暂时存放内存指令或数据
- 状态条件寄存器PSW：保存指令运行结果的条件码内容，如溢出标志

**控制器：**

从程序计数器PC里取出下一个指令的地址，然后存到指令寄存器IR中，再通过指令译码器ID。

- 程序计数器PC：存放下一个指令执行地址
- 指令寄存器IR：暂存CPU指令
- 指令译码器ID：分析指令操作码
- 地址寄存器AR：保存当前CPU访问的内存地址

## 数据表示

进制转换：二进制和十六进制

二进制符号0b、十六进制符号0x

**十进制转R进制：**例如十进制200 专为 6进制数字，得3轮余数，从下到上拼接，6进制结果 为 532

![image-20240227192017778](img/01_计算机组成与结构/image-20240227192017778.png)

**二进制转十六进制：**每四位二进制数转换为一位十六进制数，例如 二进制数0010 1101， 0010 =2  1101=D  转为十六进制数为 0x2D

二进制转八进制同理，每三位转一位八进制数。

机器数：各种数值在计算机中的表示形式，无符号数表示正数，带符号数最高位为符号位，正数符号位为0，负数符号为位1。

定点数：其中小数点不占存储位

- 定点整数（纯整数）：约定小数点的位置在机器数的最高数值位之前。
- 定点小数（纯小数)：约定小数点的位置在机器数的最低数值位之后。

真值：机器数对应的实际数值。



正数的 原码、反码、补码一样。

**原码：**数字的正常二进制表示。正数符号位为0，负数符号位为1。

**反码**：正数的反码为原码，负数反码是在原码的基础上，符号位不变，其他按位取反。

**补码：**正数的补码为原码，负数的补码=反码+1，如果进位产生溢出，则不符号位。例如 -0 的反码 1111 1111 +1 后就变成了 0000 0000 还是0。

**移码：**用作浮点运算的阶码，无论正数负数，移码=补码的符号位取反。 

数值 0 的原码有两种形式：+0 和 -0，他们的原码和反码都不相同，但是补码都是 0000 0000。

因为原码和反码有+0 和 -0区分，所以表示数据的范围要比补码少一位。



### **机器字长的带符号数取值范围**

因为带了符号位，所以在算范围的时候是 $2^{n-1}$

![image-20240227195003763](img/01_计算机组成与结构/image-20240227195003763.png)

**定点小数的表示范围** 

$定点小数的表示范围 = 定点整数的表示范围\div2^{n-1}$

**浮点数**

表示方法位 $N = F * 2^E$ ，其中 E 为阶码，F 称为尾数，类似于十进制的科学计数法，如 $85.125=0.85125*10^2，二进制如101.011 = 0.101011*2^3$

浮点数的表示中，**阶码为带符号的纯整数**，**尾数为带符号的纯小数**，这样就将一个浮点数的表示拆开成两个定点数来表示了。

格式如下：

阶符｜阶码｜数符｜尾数 

**浮点数能表示的数值量级由阶码确定，所表示的数值精度由尾数确定。**



**浮点数的运算**



### 错题

16位浮点数，其中阶符1位、阶码值6位、数符1位、尾数8位。若阶码用移码表示，尾数用补码表示，求该浮点数所能表示的数值范围？

答：浮点数的表示范围是  $尾数 * 2^{阶码}$，结果为 $-2^{63}～(1-2^{-8}2^{63})$

## 校验码

码距：在两个编码中，从A码到B码转换所需要改变的位数称为码距

### 奇偶检验码

在编码中增加 1 位校验位来使编码中1的个数为奇数（奇校验）或者偶数（偶校验），从而使码距变为2。

奇校验：编码中，含有奇数个1，发送给接收方，接收方收到后，计算编码中有多少个1

偶校验同理。

奇偶校验只能检1位错，且无法纠错。因为如果同时变了2位，编码的奇偶性不会变化。

[奇偶检验码中的码距为什么是2？](https://zhuanlan.zhihu.com/p/392092872)

> ![image-20240227225813801](img/01_计算机组成与结构/image-20240227225813801.png)

 最后可以看到，0对应的是1000  如果想要变成1，那么需要变化的位数是两个，同理变其他数字，最小的码距是2，最大码距离是4，如从1000变为 0111，需要变四位。

### CRC校验码

CRC能检错，不能纠错。

发送和接收的双方使用相同的生成多项式。    

例如：

发数据信息是1100，生成多项式为$x^3+x+1$（即1011），则CRC编码是 1100010

CRC循环校验码的编码流程：

1.在原始信息后加n个0，n为生成多项式最高阶，这里是$x^3$ 最高阶是3，所以 n=3 ，获得1100000

2.对1100000与生成多项式1011做模2除法（异或运算，同0异1），得得余数为10，不足n位时，余数左边补0，得到010

3.将原始信息与余数相连起来 得到 1100010

### 海明码

可以有多个校验位，但只能纠错一位。

本质是利用奇偶性来检错和纠错的校验方法。构成方法是在数据位之间的确定位置上插入k个校验位，通过扩大码距实现检错和纠错。

校验位是由信息位异或得到的，同理在校验的时候进行反向运算。

> 设数据位是n位，校验位是k位，则n和k必须满足以下关系：2^k-1>=n+k。

**1.校验位的位数和具体的数据位的位数之间的关系**

所有位都编号，从最低位编号，从1开始递增，校验位处于2的n （n=0 12....）次方中，即处于第1,2,4,8,16,32，……位上，其余位才能填充真正的数据位，若信息数据为1011，则可知，第1,2,4位为校验位，第3,5,6,7位为数据位，用来从低位
开始存放1011，得出信息位和校验位分布如下：

|   7   |   6   |   5   |   4   |   3   |   2   |   1   |  位数  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: |
| $I_4$ | $I_3$ | $I_2$ |       | $I_1$ |       |       | 信息位 |
|       |       |       | $r_2$ |       | $r_1$ | $r_0$ | 校验位 |

**2.计算校验码**

将所有信息位的编号都拆分二进制累加的表示法：

$7=2^2+2^1+2^0$  	$6=2^2+2^1$		$5=2^2+2^0$		$	3=2^1+2^0$

这四个信息位中，包含了r2校验位第4位（$2^2$）的有  $I_4 \quad I_3 \quad I_2$，所以 $r_2=I_4 {\bigoplus} I_3  {\bigoplus} I_2$

同理：

$r_1=I_4 {\bigoplus} I_3  {\bigoplus} I_1$

$r_0=I_4 {\bigoplus} I_2  {\bigoplus} I_1$

|  7   |  6   |  5   |  4   |  3   |  2   |  1   |  位数  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :----: |
|  1   |  0   |  1   |      |  1   |      |      | 信息位 |
|      |      |      |  0   |      |  0   |  1   | 校验位 |

所以最终要发送的海明校验码是 1010101，其中1，2，4位是校验位，3，5，6，7位是信息位。

**3.检错和纠错原理**

接收方收到海明码后，会将每一位校验位与其校验的信息位分别异或，即做如下三组运算：

$r_2{\bigoplus}I_4 {\bigoplus} I_3  {\bigoplus} I_2$

$r_1{\bigoplus}I_4 {\bigoplus} I_3  {\bigoplus} I_1$

$r_0{\bigoplus}I_4 {\bigoplus} I_2  {\bigoplus} I_1$

因为 $r_2=I_4 {\bigoplus} I_3  {\bigoplus} I_2$，所以如果传输正常的话，其实相当于在做 $r_2{\bigoplus}r_2$，如果是偶校验，结果自然全为 0

如果传输过程中第四位出错，接收到的错误数据是 1011101，

$r_2{\bigoplus}I_4 {\bigoplus} I_3  {\bigoplus} I_2$ =1

$r_1{\bigoplus}I_4 {\bigoplus} I_3  {\bigoplus} I_1$=0

$r_0{\bigoplus}I_4 {\bigoplus} I_2  {\bigoplus} I_1$=0

对应起来的二进制位就是100，即第4位出错，纠错方法是将该位逆转。

# 计算机体系结构

## 指令系统

### Flynn分类法

分类因素有两个：指令流和数据流，指令流由控制部分处理，数据流由处理器部分处理。

一条指令可以控制一条或多条数据流，但 **一条数据流还不能被多条指令控制，否则会出错，因此 多指令单数据MISD 不可能。**

![image-20240228010444491](img/01_计算机组成与结构/image-20240228010444491.png)

### 指令组成

**一条指令由操作码和操作数两部分组成**，**操作码** 决定要完成的操作，**操作数** 指参加运算的数据及其所在的单元地址。
在计算机中，操作要求和操作数地址都由二进制数码表示，分别称作操作码和地址码，整条指令以二进制编码的形式存放在存储器中。

### 计算机指令的执行过程

计算机指令执行过程：**取指令一一分析指令一一执行指令** 三个步骤，首先将程序计数器Pc中的指令地址取出，送入地址总线，CPU依据指令地址去内存中取出指令内容存入指令寄存器IR；而后由指令译码器进行分析，分析指令操作码；最后执行指令，取出指令执行所需的源操作数。

### 指令寻址方式

找的是指令。

**顺序寻址方式：**当执行一段程序时，是一条指令接着一条指令地顺序执行。
**跳跃寻址方式：**指下一条指令的地址码不是由程序计数器给出，而是由本条指令直接给出。程序跳跃后，按新的指令地址开始顺序执行。因此，程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。

### 指令操作数寻址方式

找的是操作数。

立即寻址方式：指令的地址码字段指出的不是地址，而是操作数本身。
直接寻址方式：在指令的地址字段中直接指出操作数在主存中的地址。
间接寻址方式：指令地址码字段所指向的存储单元中存储的是操作数的地址。
寄存器寻址方式：指令中的地址码是寄存器的编号。
基址寻址方式（了解）：将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址，其优点是可以扩大寻址能力。
变址寻址方式（了解）：变址寻址方式计算有效地址的方法与基址寻址方式很相似，它是将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。

### CISC 和 RISC

CISC（复杂指令系统）和RISC（精简指令系统），complex 复杂，  retrench 精简

![image-20240228011420830](img/01_计算机组成与结构/image-20240228011420830.png)

### 指令流水线

为加快指令执行速度，引入指令流水线。

指令流水线原理：将指令分成不同段，每段由不同部分去处理，因此可以产生叠加的效果，让所有部件去处理指令的不同段。

指令流水线，只在RISC中使用，CISC比较复杂没有指令流水线。

![image-20240228012152645](img/01_计算机组成与结构/image-20240228012152645.png)

RISC 中的流水线技术：

1. 超流水线（Super Pipe Line）技术。它通过**细化流水、增加级数和提高主频**，使得在每个机器周期内能完成一个甚至两个浮点操作。其实质是以时间换取空间。
2. 超标量（Super Scalar）技术。它通过**内装多条流水线来同时执行多个处理，**其时钟频率虽然与一般流水接近，却有更小的CPI。其实质是以**空间换取时间。**
3. 超长指令字（Very Long Instruction Word, VLIw） 技术。VLIW 和超标量都是20世纪80 年代出现的概念，其共同点是要同时执行多条指令，其不同在于超标量依靠硬件来实现并行处理的调度，**VLIW 则充分发挥软件的作用**，而使硬件简化，性能提高。

### 流水线时间计算

**流水线周期**：指令分成不同执行段，其中执行时间最长的段为流水线周期。

**流水线执行时间**：1条指令总执行时间+（总指令条数-1）*流水线周期。

**流水线吞吐率计算**：吞吐率即单位时间内执行的指令条数。
公式：指令条数/流水线执行时间。

**流水线的加速比计算**：加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高，
公式：不使用流水线执行时间/使用流水线执行时间。


## 存储系统

## 输入/输出技术

## 总线结构

# 可靠性

## 计算机可靠性计算





