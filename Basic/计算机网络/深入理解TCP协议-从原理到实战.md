参考：

https://tf2jaguar.github.io/understand-tcp-in-depth.html#%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%88Transport-Layer%EF%BC%89



# 网络模型分层

本分层是基于TCP/IP协议层的网络模型分层。

分层的好处是：

- 各层独立：限制了依赖关系的范围，各层之前使用标准化接口，不需要知道上下层的内部实现
- 灵活性更好：比如路由器不需要应用层和传输层，分层以后路由器就可以只用加载更少的几个协议层
- 易于测试和维护：提高了可测试性，可以独立的测试特定层，某一层有了更好的实现可以整体替换掉

![image-20241018173244199](img/深入理解TCP协议-从原理到实战/image-20241018173244199.png)

## 应用层

应用层，控制应用之间是如何互相传递报文的。**定义报文的格式和内容。**传输的数据被称为消息（message）。

- 报文的类型，是请求报文还是响应报文
- 报文的语法，报文分为几段，各段是什么含义、用什么分隔，每个部分的每个字段什么什么含义
- 进程应该以什么样的时序发送报文和处理响应报文

HTTP（GET/POST）属于应用层，除了我们熟知的 HTTP 协议，还有下面这些非常常用的应用层协议

- 域名解析协议 DNS
- 收发邮件 SMTP 和 POP3 协议
- 时钟同步协议 NTP
- 网络文件共享协议 NFS

## 传输层

传输层，对传输行为的控制，传输控制协议（Transmission Control Protocol）简称TCP ，为下层协议提供数据包的重传、流量控制、拥塞控制，根据网络情况，什么时候重传，什么时候发送慢一些。**控制传输报文的过程**，会用端口号来标识不同的应用程序。

TCP/UDP属于传输层。传输的数据被称为 报文段（segment）/数据报（datagram） (注：TCP叫**TCP报文段**，UDP叫**UDP数据报**,也有人叫UDP段)

![4](img/深入理解TCP协议-从原理到实战/4.jpg)

## 网络互联层（网络层）

IP地址属于网络层。网络层传输的是数据包（package），也叫数据分组。

IP 协议是网络层的主要协议，TCP 和 UDP 都是用 IP 协议作为网络层协议。这一层的主要作用是给包加上源ip地址和目标ip地址，将数据包传送到目标地址。

![3](img/深入理解TCP协议-从原理到实战/3.jpg)

Q：收到 IP 数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）？

A：数据包的首部会包含对应数据段所使用的传输层协议。

## 网络访问层（数据链路层）

数据链路层传送的是帧（frame），对网络层传输过来的数据包进行加工，添加帧头、帧尾和校验值，此时数据包就改名叫数据帧了。

MAC地址属于数据链路层。以太网、Wifi、蓝牙工作在这一层，主要提供了主机连接到物理网络需要的硬件的相关协议。

<img src="img/深入理解TCP协议-从原理到实战/1.png" alt="1" style="zoom: 150%;" />

## 数据传输类比快递

1. **应用层（Application Layer）**：

   应用层是最接近用户的一层，它负责处理特定的应用程序数据。应用层确保用户能够方便地发送和接收数据。这一层包括了我们日常使用的应用程序，比如电子邮件、网页浏览器和文件传输程序。在快递的例子中，应用层就像是客户填写快递单、打包包裹和接收包裹的过程。应用层确保数据能够以用户可以理解和使用的形式进行传输。

2. **传输层（Transport Layer）**：

   传输层负责确保数据的可靠传输，就像给快递包裹贴上快递单一样。在传输层，数据被分成小的单元，这些单元被称为“数据报”（Segment）。就像快递单上会写明收件人和寄件人的信息，数据报中包含了控制信息，比如端口号（类比寄件人和收件人详细地址），这些信息帮助确定数据应该被送到哪个应用程序。

3. **网络层（Network Layer）**：

   网络层处理的是数据包从一个地方传输到另一个地方的问题，就像快递公司将包裹从一个城市运到另一个城市。在网络层，数据报被进一步封装成“数据包”（Packet）。数据包上会有**源ip地址和目的ip地址**（类比寄件城市和收件城市），就像快递包裹上的收件地址和寄件地址，确保数据能够正确地从发送者传输到接收者。

4. **数据链路层（Data Link Layer）**：

   数据链路层负责在相邻的网络设备之间传输数据，这就像是快递小哥将包裹送到收件人手中。在数据链路层，网络层的数据包被封装成“数据帧”（Frame）。数据帧包含了额外的信息，比如帧同步、错误检测和物理地址（**MAC**地址类比收件人的身份证号），这些信息帮助确保数据在局域网内的正确传输。

5. **物理层（Physical Layer）**：

   物理层是整个网络通信的基础，就像快递服务中的卡车、飞机、轮船和道路。这一层负责实际的物理传输，即将数据帧通过电缆（如以太网线）、无线电波（如Wi-Fi）或者光纤等物理媒介传输。在快递的例子中，物理层就像是快递包裹的物理移动过程，包括包裹的装载、运输和卸载。



# TCP协议概述

TCP协议是 **面向连接的**、 **可靠的**、**基于字节流的**、**全双工** 的协议。

## TCP 是面向连接的协议

一开始学习 TCP 的时候，我们就被告知 TCP 是面向连接的协议，那什么是面向连接，什么是无连接呢？

- 面向连接（connection-oriented）：面向连接的协议要求正式发送数据之前需要通过「握手」建立一个**逻辑**连接，结束通信时也是通过有序的四次挥手来断开连接。
- 无连接（connectionless）：无连接的协议则不需要

### 三次握手

建立连接的过程是通过「三次握手」来完成的，顾名思义，通过三次数据交换建立一个连接。 通过三次握手协商好双方后续通信的起始序列号、窗口缩放大小等信息。

![image-20241018175424451](img/深入理解TCP协议-从原理到实战/image-20241018175424451.png)

### 全连接和半连接

**半连接**：是指在TCP三次握手过程中，客户端向服务器发送SYN请求后，服务器收到并回复SYN+ACK，此时连接处于SYN_RCVD状态。这种状态下的连接被称为半连接，因为此时连接尚未完全建立，客户端还需要发送一个ACK确认包来完成三次握手，使连接进入ESTABLISHED状态。在Linux内核中，半连接会存储在半连接队列（SYN队列）中。

**全连接**：是指TCP三次握手完成后，客户端和服务器之间的连接完全建立，处于ESTABLISHED状态。此时，连接被存储在全连接队列（accept队列）中，等待应用程序通过`accept`函数将其取出。

## TCP 协议是可靠的

IP 是一种无连接、不可靠的协议：它尽最大可能将数据报从发送者传输给接收者，但并不保证包到达的顺序会与它们被传输的顺序一致，也不保证包是否重复，甚至都不保证包是否会达到接收者。

TCP 要想在 IP 基础上构建可靠的传输层协议，必须有一个复杂的机制来保障可靠性。 主要有下面几个方面：

- 对每个包提供校验和
- 包的序列号解决了接收数据的乱序、重复问题
- 超时重传
- 流量控制、拥塞控制

**校验和（checksum）** 每个 TCP 包首部中都有两字节用来表示校验和，防止在传输过程中有损坏。如果收到一个校验和有差错的报文，TCP 不会发送任何确认直接丢弃它，等待发送端重传。

![image-20241018175657149](img/深入理解TCP协议-从原理到实战/image-20241018175657149.png)

**包的序列号保证了接收数据的乱序和重复问题** 假设我们往 TCP 套接字里写 3000 字节的数据导致 TCP发送了 3 个数据包，每个数据包大小为 1000 字节：第一个包序列号为[1~1001)，第二个包序列号为 [1001～2001)，第三个包序号为[2001~3001)

![image-20241018175947999](img/深入理解TCP协议-从原理到实战/image-20241018175947999.png)

假如因为网络的原因导致第二个、第三个包先到接收端，第一个包最后才到，接收端也不会因为他们到达的顺序不一致把包弄错，TCP 会根据他们的序号进行重新的排列然后把结果传递给上层应用程序。

如果 TCP 接收到重复的数据，可能的原因是超时重传了两次但这个包并没有丢失，接收端会收到两次同样的数据，它能够根据包序号丢弃重复的数据。

### 超时重传 

TCP 发送数据后会启动一个定时器，等待对端确认收到这个数据包。如果在指定的时间内没有收到 ACK 确认，就会重传数据包，然后等待更长时间，如果还没有收到就再重传，在多次重传仍然失败以后，TCP 会放弃这个包。

### 流量控制 TODO

### 拥塞控制 TODO

## 面向字节流的

## 全双工的





# TODO



1. <font style="background-color:yellow;">HTTP报文</font>结构

请求行：请求方法get/post，url，http版本

请求头：用户标识，请求体长度，类型，cookie

请求体：内容



状态行：http版本，状态码，状态消息

响应头：内容长度，内容类型

响应体：内容

2. <font style="background-color:yellow;">TCP报文</font>结构

源端口和目的端口，序号（乱序重排），确认号（应答机制），数据偏移（头部长度），标志位（ACK，FIN，SYN），接收窗口（流量控制），校验和（数据校验）

3. <font style="background-color:yellow;">Socket</font>通信的基本流程，使用的函数，TCP三次握手对应了socket里面的哪些流程

在客户端和服务器端分别创建一个Socket对象

在服务器端，调用bind()函数绑定服务器的IP地址和端口号

在客户端，调用connect()函数连接对应ip和端口号的服务器。在服务器端，调用listen()函数监听连接请求，最后调用accept()函数接受客户端的连接。

建立连接后，客户端和服务端都可以通过socket对象发送和接受数据，用send()发送数据，recv()接收数据

通信结束后分别调用close()关闭连接

4. <font style="background-color:yellow;">TCP</font>中的<font style="background-color:yellow;">端口</font>有什么作用

唯一标识应用程序，连接和数据流，实现了数据的准确传输和多应用程序并发运行的需求

5. TCP<font style="background-color:yellow;">三次握手</font>过程

第一次握手：**SYN_SENT**

1.客户端将SYN标志位置为1 

2.生成一个序列号seq=J，进入SYN_SENT状态

第二次握手： **SYN_RCVD**

1.服务器端接收客户端的连接： ACK=1 

2.服务器会回发一个确认序号： ack=客户端的序号 + 1

3.服务器端会向客户端发起连接请求： SYN=1 

4.服务器会生成一个随机序号：seq = K 

第三次握手： **ESTABLISHED**

1.客户单应答服务器的连接请求：ACK=1 

2.客户端回复收到了服务器端的数据：ack=服务端的序号 + 1

6. <font style="background-color:yellow;">TCP慢启动</font>算法讲一下（<font style="background-color:yellow;">拥塞控制</font>算法流程）

拥塞控制主要由：慢启动，拥塞避免，快重传，快恢复组成

慢启动：刚开始发送数据时，先把拥塞窗口设置成一个最大报文段MSS，每经过一个传输轮次RTT后拥塞窗口翻倍

拥塞避免：当拥塞窗口达到慢开始门限，开始拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个RTT只增加1MSS

如果这期间网络出现拥塞（没有收到确认），就把慢开始门限ssthresh设置为出现拥塞时发送方窗口值的一半，然后把拥塞窗口cwnd重新设置为1，执行慢开始（不使用快重传的情况）

快重传：当 TCP 接收方收到一个“乱序”的数据包时，它会立即发送一个重复确认给发送方。如果发送方收到连续的三个重复确认，则认为这个数据包丢失，并立即重传该数据包，而不必等待超时。

快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。

7. <font style="background-color:yellow;">TCP</font>和<font style="background-color:yellow;">UDP</font>区别

TCP是面向连接的，UDP无连接

TCP可靠，UDP不可靠

TCP只支持点到点通信，UDP支持一对一，一对多，多对一，多对多

TCP面向字节流，UDP面向报文

TCP有拥塞控制机制，UDP没有，网络出现拥塞不会使主机发送速率降低

TCP首部开销（20字节）比UDP首部开销（8字节）要大

8. 如何去<font style="background-color:yellow;">优化TCP传输协议</font>，若在跨服务，较长链路情况下

开启tcpFastOpen（基于cookie），可以将客户端再次发起请求的握手减少至1RTT。长链路情况（高时延带宽积）应增大发送窗口。增大发送、接受缓冲区。启用SACK，避免重复传输。优化timewait状态，如减少时间，复用timewait等。

9. <font style="background-color:yellow;">TCP/IP四层</font>主要是哪四层，都有哪些协议，OSI七层哪七层

应用层：http，dns，ftp，ssh

传输层：tcp，udp

网络层：ip，arp

网络接口层



应用层、表示层、会话层/传输层/网络层/数据链路层、物理层

10. 为什么TCP要设置<font style="background-color:yellow;">MSS（最大报文长度）</font>

防止报文过长，在IP层进行分片，而网络层没有重传机制，若发生丢失，则整个的TCP报文都要重传。

11. 如何通过<font style="background-color:yellow;">UDP</font>实现<font style="background-color:yellow;">可靠传输</font>

QUIC协议（多路复用），当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响；连接时减少了握手交互次数

12. <font style="background-color:yellow;">TCP</font>怎么实现<font style="background-color:yellow;">可靠传输</font>

数据包校验

对失序数据包重新排序（tcp报文有序列号）

丢弃重复数据

应答机制：接收方收到数据后会发送一个确认

超时重发：发送方发出数据后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据

流量控制：确保接收端能接受发送方的数据而不会缓冲区溢出

13. <font style="background-color:yellow;">流量控制</font>和<font style="background-color:yellow;">拥塞控制</font>的<font style="background-color:yellow;">区别</font>

流量控制属于通信双方协商，拥塞控制属于通信链路全局

流量控制需要双方各维护一个发送窗、一个接受窗，对任意⼀⽅，接收窗⼤⼩由⾃身决定，发送窗⼤⼩由接收⽅响应的TCP报⽂段中窗⼝值确定；拥塞控制的拥塞窗⼝⼤⼩变化由试探性发送⼀定数据量数据探查⽹络状况后⽽⾃适应调整。

14. 详细的<font style="background-color:yellow;">流量控制</font>说一下/滑动窗口的原理是什么，如何保证消息的顺序

使用滑动窗口实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（rwnd,窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。



通过在发送方和接收方之间维护一个有序序列号，发送方发送数据时，附带序列号，接收方按照序列号顺序接收数据并进行重组

15. 怎么知道是不是达到<font style="background-color:yellow;">发送窗口的阈值</font>

可以通过监控拥塞窗口大小、接收方的接收窗口大小以及网络延迟和丢包情况等因素来判断是否达到发送窗口的阈值

16. 什么是<font style="background-color:yellow;">零窗口</font>

如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送

17. <font style="background-color:yellow;">websocket</font>协议：

用于在客户端和服务器之间进行全双工通信的协议，允许双方在单个持久连接上实时地双向发送数据。

18. <font style="background-color:yellow;">RPC</font>和<font style="background-color:yellow;">http</font>的<font style="background-color:yellow;">区别</font>

RPC是远程过程调用，允许一个程序调用位于另一台计算机上的子程序或服务，就像调用本地函数一样，相较于http更专注于远程过程调用和高效的通信；而HTTP则更适用于传输超文本和其他资源。

19. <font style="background-color:yellow;">tcp粘包</font>怎么处理：约定bit数切割

TCP粘包是指TCP的缓冲区内包含多个应用层报文



原因： 一个TCP报文包含多个应用层报文接收方未能及时从TCP缓冲区中读取数据

解决方法： 应用层报文添加包含数据长度的头部设置应用层报文的开始与结束标志应用层报文固定长度

20. <font style="background-color:yellow;">https</font>和<font style="background-color:yellow;">http区别</font>

端口不同：HTTP使用的是80端口，HTTPS使用443端口；HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；HTTPS由于加密解密会带来更大的CPU和内存开销；HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买

21. <font style="background-color:yellow;">TLS4次握手</font>：

客户端发起加密通信请求，协商加密和摘要算法->服务端确定加密和摘要算法和数字证书(CA)->客户端校验证书，取出公钥，对前面协商的2个随机数+再生成一个随机数加密成【会话密钥】，后续使用这个密钥加密传输；发送随机数+加密方式改变+握手结束通知->服务器使用私钥生成【会话密钥】，握手结束。

22. ssl连接过程

协商加密和摘要算法->返回证书-> 验证证书合法性，利用公钥获得数字签名->公钥加密对称秘钥和对称秘钥加密的报文摘要->服务器根据私钥获得对称秘钥，解密报文摘要，和计算的报文摘要对比->ssl建立完成

23. <font style="background-color:yellow;">非对称加密</font>和<font style="background-color:yellow;">对称加密</font>

对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4     非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA   * 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）

对称密钥加密来保证通信内容的保密性和传输效率，同时使用非对称密钥加密来保证通信双方的身份验证和会话密钥的安全传输。

24. CA具体如何实现<font style="background-color:yellow;">数字签名认证</font>的

服务器把自己的公钥注册到CA

CA用自己的私钥将服务器的公钥数字签名并颁发数字证书

客户端拿到服务器的数字证书后，使用CA的公钥确认服务器的数字证书的真实性

从数字证书获取服务器公钥后使用它对报文加密后发送，服务器用私钥对报文解密

25. <font style="background-color:yellow;">摘要算法</font>

客户端在发送明⽂之前会通过摘要算法算出明⽂的摘要值，发送的时候把「摘要值 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「摘要值」和当前算出的「摘要值」，若「摘要值」相同，说明数据是完整的。

26. https用的对称密钥还是非对称密钥，原理，建立连接的过程

都有

27. 你了解的网络攻击方式有哪些，<font style="background-color:yellow;">SYN攻击</font>的防范方法

SYN攻击：是一种利用TCP协议中的三次握手过程来对目标服务器进行拒绝服务（DDoS）的网络攻击。攻击者发送大量伪造的TCP连接请求（SYN包），但是不完成后续的握手过程，导致目标服务器耗尽资源，无法处理正常的连接请求，从而造成拒绝服务。



防范方式：

限制同时打开SYN半连接的数目缩短SYN半连接的Time out 时间关闭不必要的服务

28. 浏览器中<font style="background-color:yellow;">输入URL</font>后发生了什么

1、当用户在浏览器中输入网址时，首先会进行DNS解析，将域名转换为对应的IP地址。浏览器会向本地DNS服务器发出DNS查询请求，如果本地DNS服务器缓存了该域名的IP地址，则直接返回；否则，本地DNS服务器会向根域名服务器、顶级域名服务器和权威域名服务器依次发出查询请求，直到获取到域名的IP地址；

2、浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立连接，发起三次握手；3、TCP/IP连接建立起来后，浏览器向服务器发送HTTP请求；4、服务器收到请求根据路径找到对应控制器处理请求，并将结果返回给浏览器；5、浏览器解析渲染，遇到js,css等静态资源引用时，再次重复上述步骤；6、最终呈现完整页面。

29. mac地址的作用

唯一标识网络设备的硬件地址

30. tcp如何判断网络是否拥塞

通过丢包情况，延迟（往返时间RTT），重传超时情况

31. <font style="background-color:yellow;">四次挥手</font>

第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。

（频繁的短连接会导致出现多个TIME_WAIT状态）

32. <font style="background-color:yellow;">get</font>和<font style="background-color:yellow;">post区别</font>

GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制

33. http中常见的<font style="background-color:yellow;">状态码</font>

2xx状态码：操作成功。200 OK3xx状态码：重定向。301 永久重定向；302暂时重定向4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；5xx状态码：服务端错误。500服务器内部错误；501服务不可用

34. <font style="background-color:yellow;">强缓存</font>和<font style="background-color:yellow;">协商缓存</font>

强缓存：在缓存有效期内，浏览器不向服务器发送请求，直接从本地缓存中读取数据。

协商缓存：每次请求都会与服务器进行交互。浏览器会向服务器发送请求，询问资源是否有更新。服务器会根据请求中的某些标识来判断资源是否发生了变化，并返回相应的响应。

35. http1.0与http1.1的区别，2.0与1.1的区别，3.0了解过吗

<font style="background-color:yellow;">1.0与1.1</font>：

使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

<font style="background-color:yellow;">2.0与1.1</font>：

头部压缩，如果同时发出多个请求，头是一样或相似的，HPACK算法会消除重复的部分；

二进制格式，头部和数据体都是二进制，统称为帧，增加数据传输的效率；

并发传输，针对不同的HTTP请求用不同的Stream ID来区分，接收端根据Stream ID有序组装HTTP消息，因此可以并发不同的Stream。

服务器推送，允许服务器主动向客户端推送资源，而不需要客户端显式请求。



<font style="background-color:yellow;">3.0</font>：

http1.1的管道虽然解决了请求的队头阻塞，但没有解决响应的队头阻塞。http2.0也存在TCP层的队头阻塞（因为TCP的流控制和拥塞控制机制会导致数据包的排队现象）。

所以3.0采用基于UDP的QUIC代替TCP，QUIC有如下特点：

无队头阻塞，当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响；

更快的连接建立，连接时减少了握手交互次数；

连接迁移，当网络环境变化时（例如从Wi-Fi切换到4G），连接可以无缝迁移，保持会话的持续性。

36. <font style="background-color:yellow;">长轮询</font>和<font style="background-color:yellow;">短轮询</font>

长轮询：客户端的请求在服务端等待，直到服务器有新的数据可用再返回响应，可以减少无效的往返次数。

短轮询：客户端定期向服务器发起请求，询问是否有新的数据，如果服务器上有新的数据就返回这些数据，否则返回空响应。







## [网络性能四大指标](https://www.eet-china.com/mp/a82420.html)

### 带宽

在网络世界里，是多指数字信号，在规定的时间内，从一端传输到另一端的数据量，即数据传输率。

我们都知道数字信息流的基本单位是bit（比特），时间按秒来算，即bps，每秒传输多少比特，所以带宽的单位可用bps来表示，bps(bit per second)

### 时延

其实就是时间的意思，指报文从A传输到B所需的**时间**。好比如，快递从深圳发出寄到北京需要1天，那么时延就等于1天。

时延还可以细分4大类，发送时延，传播时延，处理时延，排队时延。

### 抖动

所谓抖动，就是偏离了预期的时延，即不稳定的时延，网络抖动主要是指最大延迟与最小延迟的时间差。

网络抖动是无法完全消除的，受环境变化影响。如干扰、网络拥塞情况等，都可造成网络抖动。

### 丢包

造成丢包的原因有很多，比如 设备网卡处理不了过多的数据，网络拥塞、就会发生丢包。

所谓的**丢包率**，就是丢失数据包总的数量 占 总发出的数据包数量的 比率。
