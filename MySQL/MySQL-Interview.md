# InnoDB事务

## 数据库事务ACID

### 原子性

Atomic，事务是一个最小的执行单位，不可分割。事务中的多个操作要么都成功，要么都失败。已经执行的SQL语句要执行回滚，回滚到事务之前到状态。

回滚的实现原理是 **undo log**，这个是 InnoDB数据库引擎，提供的两种事务日志之一，另外一种是 **redo log**。

当事务对数据库修改的时候，InnoDB生成对应的 undo log，如果事务发生回滚，那么会执行相反的操作。

### 持久性

Durability，事务一旦提交，那么对数据库的影响是永久性的。实现原理是 **redo log**。

**redo log 出现背景**

由于数据文件是持久化在磁盘上的，每次读取数据都需要经过磁盘的 **IO**，效率比较低下。因此 InnoDB 提供了一个缓存 buffer，包含了磁盘中的部分数据页。作为访问数据库的一个缓冲区。

读数据时，先读缓冲区，没有再去读数据库，然后再将读到的数据放入缓冲区中；写数据时，也是写到缓冲区就返回，定期将 buffer 中的数据刷新到磁盘上，进行持久化。

这里存在风险是，buffer 中已被修改的数据还没来得及持久化，MySQL发生宕机，那么就会造成数据丢失。

因此引入了 redo log 来解决这个问题。

**redo log 原理**

redo log 是一种预写式日志，它会将所有的修改先写入日志，再更新 buffer，这样宕机恢复后就可以从 redo log 中恢复数据。

**redo log 也是要将操作记录日志写到磁盘，为什么不直接将 buffer 中数据写入磁盘？**

- buffer 中的数据写入磁盘是随机读写IO，而 redo log 是往日志文件中追加写的，是顺序读写IO。效率会比较高。
- buffer 持久化数据是以数据页 page 为单位的，默认配置大小是16k，一点修改都需要将整个 page 页的数据写入磁盘，存在大量无效的IO，而 redo log 只会同步发生操作的数据，所以比较快。

**buffer 中 redo log 同步磁盘的时机**

通过 innodb_flush_log_at_trx_commit 来配置 redo log 的同步时机。

- 0：等待主线程每秒刷新
- 1：每次事务提交时，**同步** 将缓冲区的 redo 日志写入到磁盘
- 2：每次事务提交时，**异步** 将缓冲区的 redo 日志写入到磁盘

### 隔离性

Isolation，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。隔离性是通过MVCC或锁机制来保证的。

MySQL 支持4种事务隔离级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）

**事务隔离级别**

- READ UNCOMMITTED：可以读取未提交的数据，未提交的数据称为脏数据，所以又称脏读。
- READ COMMITTED：RC隔离级别要求解决脏读，只能读取已经提交的数据；
- REPEATABLE READ：InnoDB默认，同一个事务中多次执行同一个select,读取到的数据没有发生改变；RR隔离级别要求解决不可重复读。
- SERIALIZABLE: 幻读，不可重复读和脏读都不允许，所以serializable要求解决幻读；

**事务隔离性问题**

- 脏读：读取到其他事务未提交的数据。

- 不可重复读：读到其他其他事务已经提交的数据。

- 幻读：同一个事务中多次执行同一个select, 读取到的数据行发生改变。也就是行数减少或者增加了(被其它事务delete/insert并且提交)。

### 一致性

Consistency， 事务操作之后, 数据库所处的状态和业务规则是一致的。数据库通过原子性、隔离性、持久性来保证一致性，一致性是目的，AID是手段。



## MVCC

RC和RR的区别是在于创建读快照的时机不同。

RC 是在每次查询的时候生成一个新的 ReadView，一个事务可能生成多个 ReadView

RR 是在第一次查询的时候生成一个ReadView，后边的查询都使用同一个。一个事务只会生成一个ReadView

**InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它通过next-key lock 锁（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。**

写-写操作：锁

写-读操作：MVCC

```mysql
# 查看锁的概况
select * from information_schema.innodb_locks;

# InnoDB整体状态，其中包括锁的情况
show engine innodb status;

# 查看事务状态
SELECT * FROM information_schema.INNODB_TRX;
# 查看正在锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
# 查看等待锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```

## 为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？

|     场景     |          分库分表前          |                  分库分表后                  |
| :----------: | :--------------------------: | :------------------------------------------: |
| 并发支撑情况 | MySQL 单机部署，扛不住高并发 |  MySQL从单机到多机，能承受的并发增加了多倍   |
| 磁盘使用情况 |  MySQL 单机磁盘容量几乎撑满  | 拆分为多个库，数据库服务器磁盘使用率大大降低 |
| SQL 执行性能 | 单表数据量太大，SQL 越跑越慢 |     单表数据量减少，SQL 执行效率明显提升     |

单库最多支撑到并发 2000，健康的单库并发值你最好保持在每秒 1000 左右

**单表数据量太大**，会极大影响你的 sql **执行的性能**，因此将每个表的记录数量控制在200w到500w左右

## 用过哪些分库分表中间件？

- 客户端：分片逻辑在应用层，封装在jar包中，通过修改或封装JDBC层来实现，如当当网的Sharding-JDBC
- 中间件代理：在业务层和数据库中间加了一个代理层，分片逻辑统一维护在中间件服务中，该服务需要独立部署，也可以多台部署，Mycat就是这种架构的实现

## 不同的分库分表中间件都有什么优点和缺点？

Sharding-jdbc 这种 client 层方案的**优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高**，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要**耦合** Sharding-jdbc 的依赖；

Mycat 这种 proxy 层方案的**缺点在于需要部署**，自己运维一套中间件，运维成本高，但是**好处在于对于各个项目是透明的**，如果遇到升级之类的都是自己中间件那里搞就行了。

通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。

## 你们具体是如何对数据库如何进行垂直拆分或水平拆分的



# 数据库锁

​	粒度
​		全局锁
​				对整个数据库加锁，让整个数据库处于只读状态，flush tables with read lock
​			作用
​				让整个数据库处于只读状态，数据更新、表字段定义等语句会被阻塞
​			使用场景
​				做全局逻辑备份
​		表级锁
​			表锁
​					对整张表加锁，除了会限制其它线程的读写，也会限制本线程接下来的操作，lock tables ... read/write，unlock tables
​					多用于并发处理
​				使用场景
​					在行锁出现之前用来处理并发问题
​			MDL锁
​				定义
​					MetaData Lock元数据锁
​				作用
​					保证读写的正确性，当对一个表做增删改查操作的时候，加MDL读锁；当要对表表结构变更的时候，加MDL写锁
​					读锁与读锁之间不互斥，因此可以有多个线程同时对一张表增删改查；读写锁、写写锁之间是互斥的，用来保证表结构变更操作的安全性。因此，如果有两个线程同时给一张表做结构变更，其中一个要等另一个执行完才能开始执行。
​				使用场景
​					MySQL5.5版本引入MDL锁，不需要显示访问，在访问一个表时会被自动加上
​		行锁
​			定义
​				针对数据表中行记录的锁，由各个存储引擎自行实现；行锁在事务提交或者回滚后才会释放
​			作用
​				当有多条线程更新同一行记录时，未持有锁的事务将会被阻塞，直至持有锁才能继续执行
​			使用场景
​				InnoDB引擎支持，用于处理并发场景
​			分类
​				乐观锁
​					定义
​						乐观锁认为自己在使用数据的时候不会有其它线程来修改数据，因此不会添加锁，只在更新时去判断之前是否有其它线程更新了这个数据。
​					实现方式
​						版本号机制
​						CAS算法
​							定义
​								全称Compare And Swap(比较并替换),是一种无锁算法，可以在不使用锁的情况下实现多线程之间的变量同步
​							特点
​								在不使用锁的情况下实现多线程之间的变量同步
​							使用场景
​								java.util.concurrent包中的原子类就是通过CAS实现的
​					作用
​					使用场景
​						适合读操作多的应用场景，不加锁的特定能够使读操作的性能大幅提升
​				悲观锁
​					定义
​						悲观所认为自己在使用数据的时候会有别的线程来修改数据，所以在获取数据时会显示加上锁，确保数据不会被其它线程修改
​					作用
​						并发场景下确保数据的准确性
​					使用场景
​						适合写操作比较多的场景，加锁的特点能够保证数据的准确性
​	类型
​		共享锁
​			定义
​				同一时刻可以被多个线程同时占有锁资源
​			作用
​			使用场景
​		排他锁（独占锁）
​			定义
​				同一时刻，只能有一个线程占有锁资源
​				如果线程t1对数据A加上独占锁后，其它线程将不能再对A加任何类型的锁，获得排他锁的线程既能读数据也能写数据
​			作用
​			使用场景
​				Synchronized
​				Lock

数据结构
	B树
	B+树
		每一个索引在InnoDB里对应一颗B+树
	哈希表

日志文件
	undo log(回滚日志)
		定义
			undo log是逻辑日志，用来记录数据库表的行信息
			默认保存在共享空间表中，位于mysql目录的data子目录的ibdata1文件
		作用
			用于保证事务的原子性和事务并发控制
			当事务发生异常或显示回滚时，MySQL使用undo log回滚数据
		使用场景
			当delete一条记录时，undo log里会记录一条insert日志；update时也会记录一条相反的update日志
		写入与释放
			undo log在事务刚开始时就会产生，保存事务开始前的数据
			undo log也会产生redo log
			mysql5.7 之后有独立的undo 表空间
			当事务提交后，undo log并不能被马上删除，而是由purge线程判断是否还有事务在使用undo log记录的信息，以此决定是否释放日志空间。
	redo log(重做日志)
		定义
		作用
		使用场景
	binlog(归档日志)
		定义
		作用
			用于记录数据库执行的写入操作（不包括查询）信息，以二进制保存在磁盘中；binlog通过追加的方式进行写入，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志
		执行流程
		使用场景
			主从复制
			数据恢复
			ES监听
		日志格式
	general log(通用日志)
	relay log(中继日志)

存储引擎
	InnoDB
		介绍
			InnoDB是将表数据存储到磁盘上的存储引擎，所以即使服务器重启后数据还是存在的
		数据处理过程
			数据处理的过程发生在内存中，所以需要把磁盘中的数据加载到内存中，如果是处理写入或者修改请求的话，还需要把内存中的内容刷新到磁盘上。但是读写磁盘的速度非常慢，一条一条把记录从磁盘读出来会非常慢，InnoDB采用的方式是：将数据划分为若干个页，以页作为磁盘和内存间交互的基本单位，页的大小一般为16kb，也就是说，一般情况下，一次最少从磁盘中读取16kb的内容到内存中，一次最少把内存中16kb内容刷新到磁盘中。
		InnoDB 行格式
			介绍
				数据库是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。设计InnoDB存储引擎的大叔们到现在为止设计了4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式
			种类
				COMPACT行格式
					图例
						

					介绍
						一条完整的记录分为 记录的额外信息 和 记录的真是数据 两部分。
					组成
						记录的额外信息
							变长字段长度列表：
							NULL值列表
							记录头信息
						记录的真实数据
							子主题 1
							子主题 2
				子主题 2
				子主题 3
				子主题 4
			指定行格式语法
		数据页结构
			InnoDB记录结构
			InnoDB页结构
				介绍
					数据页是InnoDB管理存储空间的基本单位，一个页的大小一般是16kb。
				示意图
					
				组成
					File header
						文件头，存放数据页的一些通用信息
					Page Header
						页面头部，数据页专有的一些信息
					Infimum+Supremum
						最小记录和最大记录，是两个虚拟的行记录
					User Records
						用户记录，实际存储的行记录内容
					Free Space
						页中尚未使用的空间
					Page Directory
						页中某些记录的相对位置
					File Trailer
						校验页是否完整
				记录插入过程
					介绍
						存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了
					示意图
						
	MyISAM
	MEMORY

数据库连接池
	定义
		数据库连接池负责分配、管理和释放数据库连接，它允许引用程序重复使用一个现有的数据库连接，而不是重新建立一个。
	作用
		在应用启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态的对池中的连接进行申请、使用和释放，提升系统性能
		减少了每次连接数据库时的tcp连接，减少网络IO消耗
	流程
		不使用数据库连接池流程
			图例
				

			步骤
				1、TCP建立连接（三次握手）
				2、MySQL权限认证
				3、SQL执行
				4、TCP关闭连接（四次挥手）
		使用数据库连接池流程
			图例
				
			步骤
				1、第一次访问时建立TCP连接
				2、SQL执行使用的都是连接池中的连接
				3、服务停止时释放连接池
	工作原理
		连接池建立
			系统初始化时，连接池会根据系统配置建立，并在池中创建几个连接对象，连接池中的连接不能随意创建和关闭，避免随意连接和关闭造成的系统开销
		连接池管理
			首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常；
		连接池关闭
			当客户端释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留
	常用参数（HikariCP）
		1、autoCommit=true 
			连接是否自动提交事务，默认true
		2、connectionTimeout
			连接超时时间，如果超时，将抛出SQLException
		3、idleTimeout
			连接在连接池中闲置多久被抛弃，默认600000 ms
		4、minimumIdle
			最小空闲连接数
		5、maximumPoolSize
			最大连接数
		6、poolName
			连接池名称
	分类
		HikariCP
		Druid

分库分表
	sharding-jdbc
		定义
		SQL执行流程
			图例
				

			步骤
				SQL解析
					词法解析
					语法解析
				SQL路由
					sharding-jdbc根据上下文匹配用户对这句SQL所涉及的库和表配置的分片策略（用户配置的分片策略），并根据分片策略生成路由后的SQL。路由后的SQL有一条或多条，每一条都对应着各自真实的物理分片
				SQL改写
					将SQL改写成在真实数据库中可以执行的语句（例如把逻辑表名改为带编号的物理表）
				SQL执行
					通过多线程执行器异步执行改写后得到的 SQL 语句
				结果归并
					将多个执行结果集归并以便于通过统一的 JDBC 接口输出
		核心概念
			逻辑表和物理表
			分片键
			路由
			分片策略
				标准分片策略
				复合分片策略
				Hint分片策略
				Inline分片策略
				不分片策略
			分片算法
			绑定表
		使用方式
			引入依赖包
			水平分片规格配置
			创建数据源
			执行SQL

索引
	定义
		索引是用来快速查找特定记录的数据结构，能够快速的确定要查找数据所在数据文件的具体位置而不用扫描所有数据，这比按顺序读取每一行数据快很多
	模型
		哈希表
			定义
				是一种以key-value形式存储数据的结构
			原理
				底层基于数组+链表实现
			适用场景
				适用于等值查询的场景，比如一些NoSQL引擎
		有序数组
			定义
			原理
				底层基于数组实现
			适用场景
				适用于等值查询和范围查询；适用于静态存储引擎，存的是不会再修改的数据
		搜索树
			二叉搜索树
				定义
				特点
					每个节点的左儿子小于父节点，父节点又小于右儿子
				适用场景
			N叉树
				定义
				特点
				适用场景
	类型
		主键索引
			是一种特殊的唯一索引，一个表只能有一个主键，不允许空值
		唯一索引
			 定义
			语句
		普通索引
		组合索引
			多个字段上创建索引
		全文索引
		覆盖索引



基础架构
	图例
		

	连接器
		管理连接，权限验证
	分析器
		词法分析，语法分析
	优化器
		生成执行计划，索引选择
			索引选择
				索引的行数
				是否回表操作
				是否使用临时表
				是否使用排序或者文件排序
	执行器
		操作存储引擎，返回结果
	存储引擎
		存储数据，提供读写接口